Project Structure & Dependencies

TestBlazor/
│
├── src/
│   ├── TestBlazor.Domain/              (No dependencies)
│   │   # Entities, Value Objects, Domain Events
│   │   # Interfaces (e.g., IKafkaProducer, IRepository)
│   │   # Pure domain logic, no infra or external libs
│   │
│   ├── TestBlazor.Application/         (→ Domain only)
│   │   # MediatR commands, queries, handlers, validations
│   │
│   ├── TestBlazor.Infrastructure/      (→ Domain only)
│   │   # Implements domain interfaces (e.g., IKafkaProducer)
│   │   # Kafka, EF Core, config, DI registration
│   │
│   ├── TestBlazor.Contracts/           (No dependencies)
│   │   # DTOs, Integration Events, Enums for API-client communication
│   │
│   ├── TestBlazor.API/                 (→ Application + Contracts + Infrastructure for DI only)
│   │   # REST controllers, MediatR injection, mapping Contracts ↔ Application
│   │
│   ├── TestBlazor.BlazorUI/            (→ BlazorUI.Client only)
│   │   # Host for Blazor WASM client app
│   │
│   ├── TestBlazor.BlazorUI.Client/     (→ Contracts only)
│   │   # Blazor WASM app, calls API endpoints using DTOs
│   │
│   └── TestBlazor.BackgroundWorker/    (→ Application + Contracts)
│       # Kafka consumer background service, maps messages to Application commands



Dependency Rules Summary
    Domain: Pure core, no external dependencies
    Application: Depends only on Domain
    Infrastructure: Depends only on Domain (implements interfaces)
    Contracts: No dependencies (used for DTOs)
    API: Depends on Application, Contracts, and Infrastructure only for DI registration (implementations hidden as internal)
    BlazorUI (Host): Depends only on BlazorUI.Client
    BlazorUI.Client: Depends only on Contracts
    BackgroundWorker: Depends on Application and Contracts

NuGet Packages (per project)
    Domain: None (or minimal, like System.Collections.Immutable)
    Application: MediatR, FluentValidation, Logging.Abstractions
    Infrastructure: Confluent.Kafka, EF Core, Configuration, DI, Logging, Newtonsoft.Json
    Contracts: None (optional serialization packages)
    API: ASP.NET Core MVC, MediatR DI, AutoMapper, Swagger
    BlazorUI.Host: Blazor WASM hosting packages
    BlazorUI.Client: Blazor WASM packages, HttpClient
    BackgroundWorker: Hosting, Confluent.Kafka, MediatR DI, Logging, Configuration

DI & Implementation Note
    Reference Infrastructure only from API for DI registration.
    Keep infrastructure classes internal to prevent accidental direct usage outside of DI.
    Application works through Domain interfaces only.


Kafka Docker Compose (simplified)

version: '3.8'

services:
  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    ports:
      - 2181:2181
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000

  kafka:
    image: confluentinc/cp-kafka:latest
    depends_on:
      - zookeeper
    ports:
      - 9092:9092
      - 29092:29092
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:29092,PLAINTEXT_HOST://0.0.0.0:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT

  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    ports:
      - 8080:8080
    environment:
      KAFKA_CLUSTERS_0_NAME: local
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:29092
      KAFKA_CLUSTERS_0_ZOOKEEPER: zookeeper:2181
    depends_on:
      - kafka
      - zookeeper

Flow Summary (Create Location Topic)

    User clicks Create Location button in BlazorUI.Client
    Client sends HTTP POST to API with DTO (Contracts)
    API maps DTO → Application Command, sends via MediatR
    Application validates and creates Domain entity
    Application uses Domain interface (e.g., IKafkaProducer) to publish event
    Infrastructure implements IKafkaProducer, produces Kafka message on Location topic