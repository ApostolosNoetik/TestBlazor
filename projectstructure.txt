TestBlazor/
│
├── src/
│   ├── TestBlazor.Domain/                (Class Library - No external deps)
│   │   # Entities, Value Objects, Domain Events
│   │   # Interfaces: IRepository<T>, IKafkaProducer, IKafkaConsumer, IUnitOfWork, etc.
│   │   # Domain services (pure business logic)
│   │
│   ├── TestBlazor.Application/           (Class Library - MediatR, FluentValidation, Logging Abstractions)
│   │   → TestBlazor.Domain
│   │   # Application services, commands, queries, MediatR handlers
│   │
│   ├── TestBlazor.Infrastructure/        (Class Library - Kafka, EFCore, Configuration, Logging, Newtonsoft.Json)
│   │   → TestBlazor.Domain
│   │   # Implements Domain interfaces, persistence, Kafka, DI registrations
│   │
│   ├── TestBlazor.Contracts/             (Class Library - DTOs, Integration Events, Enums, JSON serialization)
│   │   # No dependencies
│   │
│   ├── TestBlazor.API/                   (ASP.NET Core Web API)
│   │   → TestBlazor.Application
│   │   → TestBlazor.Contracts
│   │   # Exposes REST endpoints, maps Contracts ↔ Domain models, calls Application via MediatR
│   │
│   ├── TestBlazor.BlazorUI/              (ASP.NET Core Host for Blazor WebAssembly)
│   │   → TestBlazor.BlazorUI.Client
│   │   # Hosts Blazor client, serves static files, optional API proxies
│   │
│   ├── TestBlazor.BlazorUI.Client/       (Blazor WebAssembly App)
│   │   → TestBlazor.Contracts
│   │   # Runs in browser, calls API endpoints
│   │
│   └── TestBlazor.BackgroundWorker/       (Worker Service / Console App - Kafka Consumer)
│       → TestBlazor.Application
│       → TestBlazor.Contracts
│       # Background service consuming Kafka, sending commands to Application .............i want strict ddd rules to apply to this small project, are this dependancies correct, int he communication rules correct and reflec the following, or i have mistake somewhere Domain → nothing
(Pure core, no dependencies)


------- PROJECT DEPENDANCIES -------

Application → Domain only
(Business logic, interfaces from Domain only)

Infrastructure → Domain only
(Implements Domain interfaces, persistence, Kafka)

Contracts → nothing
(DTOs and enums only, no dependencies)

API → Application + Contracts
(Exposes endpoints, maps Contracts ↔ Domain models, sends commands/queries to Application)

BlazorUI (Host) → BlazorUI.Client only
(Hosts the client app, serves static files; no direct Domain/Application/Contracts references)

BlazorUI.Client → Contracts only
(Runs in browser, calls API via HTTP, uses DTOs from Contracts)

BackgroundWorker → Application + Contracts
(Consumes Kafka messages, maps to Application commands, uses Contracts for DTOs) 



------- ADD NUGGET PACKAGES -------
TestBlazor.Domain
No external packages (pure domain)
Possibly System.Collections.Immutable (optional, for value objects)
TestBlazor.Application
MediatR
FluentValidation
Microsoft.Extensions.Logging.Abstractions

TestBlazor.Infrastructure
Confluent.Kafka (Kafka client)
Microsoft.EntityFrameworkCore (and relevant provider, e.g. SqlServer, Npgsql)
Microsoft.Extensions.Configuration (for config)
Microsoft.Extensions.DependencyInjection (DI)
Microsoft.Extensions.Logging
Newtonsoft.Json (for serialization)

TestBlazor.Contracts
No packages needed, unless for serialization attributes you want (e.g., System.Text.Json or Newtonsoft.Json), but usually none needed here

TestBlazor.API
Microsoft.AspNetCore.App (includes MVC, controllers, routing)
MediatR.Extensions.Microsoft.DependencyInjection
AutoMapper.Extensions.Microsoft.DependencyInjection (optional, for mapping Contracts ↔ Domain)
Microsoft.Extensions.Logging
Swashbuckle.AspNetCore (optional, Swagger)

TestBlazor.BlazorUI (Host)
Microsoft.AspNetCore.Components.WebAssembly.Server (host for WASM)
Microsoft.Extensions.Logging

TestBlazor.BlazorUI.Client
Microsoft.AspNetCore.Components.WebAssembly
Microsoft.AspNetCore.Components.WebAssembly.Http
Microsoft.Extensions.Http
System.Net.Http.Json
Possibly MediatR client packages if using MediatR on client (optional)

TestBlazor.BackgroundWorker
Microsoft.Extensions.Hosting (worker service)
Confluent.Kafka
MediatR.Extensions.Microsoft.DependencyInjection
Microsoft.Extensions.Logging
Microsoft.Extensions.Configuration

------- ADD Infrastructure to API (debatable, needs more research)-------
Add Infrastructure project reference to API for DI registration; keep implementation classes internal to enforce layering.

------- ADD Docker compose zookeeper, kafka, kafka-ui-------
version: '3.8'

services:
  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    container_name: zookeeper
    ports:
      - 2181:2181
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000

  kafka:
    image: confluentinc/cp-kafka:latest
    container_name: kafka
    depends_on:
      - zookeeper
    ports:
      - 9092:9092
      - 29092:29092
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:29092,PLAINTEXT_HOST://0.0.0.0:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT

  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    container_name: kafka-ui
    ports:
      - 8080:8080
    environment:
      KAFKA_CLUSTERS_0_NAME: local
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:29092
      KAFKA_CLUSTERS_0_ZOOKEEPER: zookeeper:2181
    depends_on:
      - kafka
      - zookeeper

------- Flow Create Location Topic-------
DI AddInfrastructure from Infra to API 
BlazorUI → API → Contracts (DTOs) → Application (Commands, MediatR) → Domain (Interfaces like IKafkaProducer) → Infrastructure (KafkaProducer implementation) → Kafka (Location Topic)

User clicks "Create Location" button in BlazorUI.Client.
BlazorUI.Client calls the TestBlazor.API endpoint (HTTP POST).
API maps the incoming DTO (Contracts) to an Application command.
API sends the command to Application layer via MediatR.
Application handles the command: validates business rules and creates a Location domain entity.
Application uses an interface (e.g., IKafkaProducer) defined in Domain to publish the LocationCreated event/message to Kafka (Location topic).
Infrastructure implements IKafkaProducer and actually produces the Kafka message on the Location topic.
